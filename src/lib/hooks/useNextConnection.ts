import { useQuery, useMutation, useQueryClient } from '@tanstack/react-query';
import { supabase } from '@/lib/supabase/client';
import type { NextConnection, ConnectionAgenda, Contact } from '@/types';
import type { Json } from '@/lib/supabase/types_db';
// Assuming types_db.ts will be regenerated by the user after migrations.
// import type { Database } from '@/lib/supabase/types_db';

const NEXT_CONNECTIONS_TABLE = 'next_connections';
const CONTACTS_TABLE = 'contacts';

// Type for creating a new connection, ensuring all required fields are present.
// This should align with Database['public']['Tables']['next_connections']['Insert'] once types are regenerated.
// Update: Make parameter type for createNextConnection more aligned with actual DB insert needs.
type CreateNextConnectionParams = Omit<NextConnection, 'id' | 'created_at' | 'updated_at' | 'agenda'> & {
  agenda?: Json | null; // Agenda as Json for insert
  connection_type: string; // Ensure connection_type is string
};

// --- Placeholder Supabase API functions --- 

/**
 * Fetches the most recent scheduled (or non-cancelled/non-completed) next connection for a contact.
 */
async function fetchNextConnection(contactId: string): Promise<NextConnection | null> {
  const { data, error } = await supabase
    .from(NEXT_CONNECTIONS_TABLE)
    .select('*')
    .eq('contact_id', contactId)
    .not('status', 'in', '("completed", "cancelled")') // Example: only show active ones
    .order('scheduled_date', { ascending: true })
    .limit(1)
    .maybeSingle(); // Use maybeSingle to handle 0 or 1 result gracefully

  if (error) {
    console.error('Error fetching next connection:', error);
    // After types_db.ts regeneration, this error might be more specific
    if (error.message.includes('relation "public.next_connections" does not exist')) {
        console.warn('Supabase types might be outdated. Please regenerate types after applying migrations.');
    }
    throw new Error(error.message);
  }
  return data as NextConnection | null;
}

/**
 * Creates a new next connection record.
 */
async function createNextConnection(connection: CreateNextConnectionParams): Promise<NextConnection | null> {
  const { data, error } = await supabase
    .from(NEXT_CONNECTIONS_TABLE)
    .insert(connection) // Pass connection directly, as its types align with insert now
    .select()
    .single();

  if (error) {
    console.error('Error creating next connection:', error);
    throw new Error(error.message);
  }
  return data as NextConnection | null;
}

/**
 * Updates the agenda for a specific next connection.
 */
async function updateConnectionAgenda(connectionId: string, agenda: ConnectionAgenda): Promise<NextConnection | null> {
  const { data, error } = await supabase
    .from(NEXT_CONNECTIONS_TABLE)
    .update({ agenda: agenda as Json, updated_at: new Date().toISOString() })
    .eq('id', connectionId)
    .select()
    .single();

  if (error) {
    console.error('Error updating connection agenda:', error);
    throw new Error(error.message);
  }
  return data as NextConnection | null;
}

/**
 * Updates the status of a specific next connection.
 */
async function updateConnectionStatus(connectionId: string, status: NextConnection['status']): Promise<NextConnection | null> {
  const { data, error } = await supabase
    .from(NEXT_CONNECTIONS_TABLE)
    .update({ status, updated_at: new Date().toISOString() })
    .eq('id', connectionId)
    .select()
    .single();

  if (error) {
    console.error('Error updating connection status:', error);
    throw new Error(error.message);
  }
  return data as NextConnection | null;
}

/**
 * Updates the last_interaction_date on the contact record.
 */
async function updateContactInteraction(contactId: string, interactionDate: string): Promise<Partial<Contact> | null> {
    const { data, error } = await supabase
        .from(CONTACTS_TABLE)
        .update({ last_interaction_date: interactionDate, updated_at: new Date().toISOString() })
        .eq('id', contactId)
        .select('id, last_interaction_date, updated_at') // Select only what changed or is needed
        .single();

    if (error) {
        console.error('Error updating contact last_interaction_date:', error);
        throw new Error(error.message);
    }
    return data;
}

// --- React Query Hook --- 

export const useNextConnection = (contactId: string | null) => {
  const queryClient = useQueryClient();
  const queryKey = ['next-connection', contactId];

  const { data: nextConnection, isLoading, error: queryError } = useQuery<NextConnection | null, Error>({
    queryKey: queryKey,
    queryFn: () => contactId ? fetchNextConnection(contactId) : Promise.resolve(null),
    enabled: !!contactId,
    staleTime: 5 * 60 * 1000, // 5 minutes
  });

  const scheduleConnectionMutation = useMutation<
    NextConnection | null, 
    Error, 
    // Input type for the mutation: what the UI/caller provides
    Omit<NextConnection, 'id' | 'created_at' | 'updated_at' | 'user_id' | 'connection_type'> & 
    { user_id: string; connection_type: string; } // Make connection_type required here
  >({
    mutationFn: (connectionInput) => {
      // connectionInput now has connection_type: string and agenda: ConnectionAgenda | null | undefined
      // We need to prepare an object matching CreateNextConnectionParams
      const paramsForCreate: CreateNextConnectionParams = {
        ...connectionInput,
        agenda: connectionInput.agenda as Json | null | undefined, // Cast agenda
        // connection_type is already string from connectionInput
      };
      return createNextConnection(paramsForCreate);
    },
    onSuccess: () => {
      queryClient.invalidateQueries({ queryKey });
    },
  });

  const updateAgendaMutation = useMutation<
    NextConnection | null, 
    Error, 
    { connectionId: string; agenda: ConnectionAgenda }
  >({
    mutationFn: ({ connectionId, agenda }) => updateConnectionAgenda(connectionId, agenda),
    onSuccess: (updatedConnection) => {
      queryClient.setQueryData(queryKey, updatedConnection); // Optimistically update or refetch
      // queryClient.invalidateQueries({ queryKey });
    },
  });

  const markCompletedMutation = useMutation<
    NextConnection | null, 
    Error, 
    { connectionId: string }
  >({
    mutationFn: ({ connectionId }) => updateConnectionStatus(connectionId, 'completed'),
    onSuccess: (completedConnection) => {
      queryClient.setQueryData(queryKey, (oldData) => oldData === completedConnection ? null : oldData); // Remove if it was the current one
      // Or, more robustly: queryClient.invalidateQueries({ queryKey });
      
      if (contactId) {
        updateContactInteraction(contactId, new Date().toISOString())
          .then(() => {
            queryClient.invalidateQueries({ queryKey: ['contact-profile', contactId] });
          })
          .catch(err => console.error('Failed to update contact last_interaction_date after completing connection:', err));
      }
    },
  });
  
  const updateStatusMutation = useMutation<
    NextConnection | null,
    Error,
    { connectionId: string; status: NextConnection['status'] }
  >({
    mutationFn: ({ connectionId, status }) => updateConnectionStatus(connectionId, status),
    onSuccess: (updatedConnection) => {
      queryClient.invalidateQueries({queryKey});
      if (updatedConnection?.status === 'completed' && contactId) {
         updateContactInteraction(contactId, new Date().toISOString())
          .then(() => {
            queryClient.invalidateQueries({ queryKey: ['contact-profile', contactId] });
          })
          .catch(err => console.error('Failed to update contact last_interaction_date after status update to completed:', err));
      }
    }
  });

  return {
    nextConnection,
    isLoading,
    error: queryError,
    scheduleConnection: scheduleConnectionMutation.mutateAsync,
    isSchedulingConnection: scheduleConnectionMutation.isPending,
    updateAgenda: updateAgendaMutation.mutateAsync,
    isUpdatingAgenda: updateAgendaMutation.isPending,
    markCompleted: markCompletedMutation.mutateAsync,
    isMarkingCompleted: markCompletedMutation.isPending,
    updateStatus: updateStatusMutation.mutateAsync,
    isUpdatingStatus: updateStatusMutation.isPending,
  };
}; 